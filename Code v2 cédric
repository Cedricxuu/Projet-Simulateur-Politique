import ollama
from ollama import Client
import time
import random

client = Client(host='http://localhost:11434')
mort = False
tour = 1  # Variable pour suivre le numÃ©ro du tour

# Jauges
etat = {
    "Bonheur": 50,
    "Environnement": 50,
    "Ã‰conomie": 50,
}
variation = {
    "Bonheur": 0,
    "Environnement": 0,
    "Ã‰conomie": 0,
}

def generer_probleme():
    """Demande Ã  l'IA de gÃ©nÃ©rer un problÃ¨me politique avec des impacts obligatoires pour chaque solution."""
    response = client.chat(
        model="mistral",
        messages=[
            {
                "role": "system",
                "content": 
                """RÃ¨gles Ã  respecter obligatoirement :    
                Pas d'intro/transition. 
                Tu dois gÃ©nÃ©rer un problÃ¨me politique ou Ã©conomique avec EXACTEMENT 3 solutions distinctes.
                Tu es en FRANCE obligatoirement et tu dois obligatoirement rÃ©pondre en franÃ§ais.
                
                TRÃˆS IMPORTANT : Pour chaque solution, tu dois gÃ©nÃ©rer des impacts SIGNIFICATIFS diffÃ©rents sur les jauges qui ne doivent pas Ãªtre visibles par l'utilisateur:
                - "Bonheur" (valeur entre -20 et +20, JAMAIS 0)
                - "Ã‰conomie" (valeur entre -20 et +20, JAMAIS 0)
                - "Environnement" (valeur entre -20 et +20, JAMAIS 0)
                
                Ces impacts doivent Ãªtre logiquement liÃ©s aux solutions proposÃ©es. CHAQUE JAUGE DOIT ÃŠTRE MODIFIÃ‰E, PAS DE VALEUR 0.
                
                OBLIGATOIRE ET CRUCIAL : Inclure ces impacts dans une section cachÃ©e aprÃ¨s les solutions, format:
                
                ### Impacts ###
                [1]: Bonheur:{valeur1}, Ã‰conomie:{valeur2}, Environnement:{valeur3}
                [2]: Bonheur:{valeur4}, Ã‰conomie:{valeur5}, Environnement:{valeur6}
                [3]: Bonheur:{valeur7}, Ã‰conomie:{valeur8}, Environnement:{valeur9}
                
                Les valeurs DOIVENT Ãªtre diffÃ©rentes pour chaque option.
                JAMAIS DE VALEUR 0 POUR LES IMPACTS - toujours des valeurs entre -20 et -1 ou entre +1 et +20.
                Ã‰crire en franÃ§ais exclusivement.
              
                Format strict de la rÃ©ponse visible pour l'utilisateur : 
                Une premiÃ¨re ligne dÃ©crivant le problÃ¨me (200 caractÃ¨res maximum)
                
                [1] : [description de la premiÃ¨re solution en une phrase] 
                [2] : [description de la seconde solution en une phrase] 
                [3] : [description de la troisiÃ¨me solution en une phrase] 
                """
            },
            {
                "role": "user",
                "content": "PrÃ©sente un problÃ¨me politique/Ã©conomique qui pourrait survenir."
            }
        ],
        options={
            'temperature': 0.8  # Ã‰quilibre entre crÃ©ativitÃ© et respect des consignes
        }
    )
    return response['message']['content']

def generer_impacts_via_ia(choix):
    """GÃ©nÃ¨re des impacts via l'IA quand la section impacts est mal formÃ©e."""
    print("[SystÃ¨me] Consultation de l'IA pour obtenir des impacts valides...")
    
    response = client.chat(
        model="mistral", 
        messages=[
            {
                "role": "system",
                "content": 
                """GÃ©nÃ¨re UNIQUEMENT des impacts pour une dÃ©cision politique.
                Format strict Ã  respecter :
                Bonheur:{valeur1}, Ã‰conomie:{valeur2}, Environnement:{valeur3}
                
                Chaque valeur doit Ãªtre entre -20 et +20, JAMAIS 0.
                Pas d'explication, uniquement les valeurs.
                """
            },
            {
                "role": "user", 
                "content": f"GÃ©nÃ¨re des impacts pour la solution {choix} (valeurs entre -20 et +20, jamais 0)"
            }
        ],
        options={'temperature': 0.7}
    )
    
    impacts_text = response['message']['content']
    # Extraction des impacts
    impacts = {}
    parties = impacts_text.split(",")
    
    for partie in parties:
        if ":" in partie:
            jauge_valeur = partie.strip().split(":")
            if len(jauge_valeur) == 2:
                jauge = jauge_valeur[0].strip()
                try:
                    valeur = int(jauge_valeur[1].strip().replace("+", ""))
                    if valeur == 0:  # On s'assure qu'il n'y a pas de 0
                        valeur = random.choice([-2, -1, 1, 2])
                    impacts[jauge] = valeur
                except ValueError:
                    impacts[jauge] = random.choice([-3, -2, 2, 3])
    
    # VÃ©rifier que toutes les jauges sont prÃ©sentes
    for jauge in etat.keys():
        if jauge not in impacts:
            # DerniÃ¨re tentative pour avoir une valeur valide
            impacts[jauge] = random.choice([-5, -4, -3, 3, 4, 5])
    
    return impacts

def extraire_impact(texte_complet, choix):
    """Extrait les impacts des jauges Ã  partir de la section cachÃ©e et garantit des impacts via l'IA."""
    try:
        if "### Impacts ###" not in texte_complet:
            print("[SystÃ¨me] Section d'impacts manquante, consultation de l'IA...")
            return generer_impacts_via_ia(choix)
        
        impacts_section = texte_complet.split("### Impacts ###")[1]
        lignes = impacts_section.strip().split("\n")
        
        for ligne in lignes:
            if ligne.startswith(f"[{choix}]"):
                impacts = {}
                valeurs_texte = ligne.split(":", 1)[1].strip()
                parties = valeurs_texte.split(",")
                
                for partie in parties:
                    jauge_valeur = partie.strip().split(":")
                    if len(jauge_valeur) == 2:
                        jauge = jauge_valeur[0].strip()
                        valeur_str = jauge_valeur[1].strip()
                        try:
                            valeur = int(valeur_str.replace("+", ""))
                            # Garantir un impact non-nul
                            if valeur == 0:
                                print(f"[SystÃ¨me] Impact nul dÃ©tectÃ© pour {jauge}, consultation de l'IA...")
                                # On ne gÃ©nÃ¨re pas alÃ©atoirement mais demande Ã  l'IA
                                temp_impacts = generer_impacts_via_ia(choix)
                                valeur = temp_impacts.get(jauge, random.choice([-3, -2, 2, 3]))
                            impacts[jauge] = valeur
                        except ValueError:
                            print(f"[SystÃ¨me] Impossible de parser la valeur pour {jauge}, consultation de l'IA...")
                            # Demande Ã  l'IA plutÃ´t que gÃ©nÃ©ration alÃ©atoire
                            temp_impacts = generer_impacts_via_ia(choix)
                            impacts[jauge] = temp_impacts.get(jauge, random.choice([-3, -2, 2, 3]))
                
                # VÃ©rifier que toutes les jauges sont impactÃ©es
                for jauge in etat.keys():
                    if jauge not in impacts:
                        print(f"[SystÃ¨me] Jauge {jauge} manquante, consultation de l'IA...")
                        temp_impacts = generer_impacts_via_ia(choix)
                        impacts[jauge] = temp_impacts.get(jauge, random.choice([-3, -2, 2, 3]))
                
                return impacts
        
        # Si on arrive ici, l'impact n'a pas Ã©tÃ© trouvÃ© pour le choix spÃ©cifiÃ©
        print(f"[SystÃ¨me] Impact pour le choix {choix} non trouvÃ©, consultation de l'IA...")
        return generer_impacts_via_ia(choix)
        
    except Exception as e:
        print(f"[SystÃ¨me] Erreur lors de l'extraction des impacts: {e}")
        print("[SystÃ¨me] Consultation de l'IA pour obtenir des impacts valides...")
        return generer_impacts_via_ia(choix)

def ajuster_jauges(impacts):
    """Ajuste les jauges en fonction des impacts extraits."""
    for jauge, valeur in impacts.items():
        if jauge in etat:
            # Enregistre la variation pour l'affichage au tour suivant
            variation[jauge] = valeur
            
            # Applique le changement
            etat[jauge] += valeur
            etat[jauge] = max(0, min(100, etat[jauge]))  # Limite entre 0 et 100

def afficher_probleme(texte_complet):
    """Affiche uniquement la partie visible du problÃ¨me (sans les impacts)."""
    if "### Impacts ###" in texte_complet:
        partie_visible = texte_complet.split("### Impacts ###")[0].strip()
        print(partie_visible)
    else:
        print(texte_complet)

def afficher_situation():
    """Affiche la situation actuelle avec des tendances mais sans valeurs prÃ©cises."""
    print("\nðŸ“Š Ã‰TAT DU PAYS :")
    for nom, valeur in etat.items():
        barres = int(valeur / 10)
        var = variation[nom]
        
        # Affichage des tendances sans valeurs prÃ©cises
        var_text = ""
        if var > 10:
            var_text = " (â†‘â†‘ Forte hausse)"
        elif var > 0:
            var_text = " (â†‘ Hausse)"
        elif var < -10:
            var_text = " (â†“â†“ Forte baisse)"
        elif var < 0:
            var_text = " (â†“ Baisse)"
            
        print(f"{nom:12} : [{'#' * barres}{'-' * (10 - barres)}] {valeur}/100{var_text}")
    
    # RÃ©initialise les variations pour le prochain tour
    for key in variation:
        variation[key] = 0
        
    if any(valeur <= 0 for valeur in etat.values()):
        print("\nðŸ’¥ Une des structures du pays s'effondre. GAME OVER.")
        return True
    return False

def verifier_format_reponse(texte):
    """VÃ©rifie que la rÃ©ponse de l'IA contient bien 3 options et les impacts."""
    lignes = texte.split("\n")
    options_count = sum(1 for ligne in lignes if ligne.strip().startswith("[") and "]" in ligne)
    
    # VÃ©rifie si la section d'impacts est prÃ©sente
    impacts_present = "### Impacts ###" in texte
    
    if options_count < 3 or not impacts_present:
        return False
    return True

def intro_jeu():
    print("\n" + "="*60)
    print("ðŸ›ï¸  SIMULATEUR DE GOUVERNANCE POLITIQUE  ðŸ›ï¸")
    print("="*60)
    print("\nVous Ãªtes Ã  la tÃªte de la France et devez prendre des dÃ©cisions difficiles.")
    print("Chaque choix aura des consÃ©quences sur le bonheur de la population,")
    print("l'Ã©conomie et l'environnement. Maintenez l'Ã©quilibre pour survivre!")
    print("\nObjectif: EmpÃªcher qu'une jauge tombe Ã  zÃ©ro.")
    print("="*60)

# Programme principal
intro_jeu()
print(f"\nðŸ”„ Tour nÂ°{tour}")

while not mort:
    # GÃ©nÃ¨re un nouveau problÃ¨me avec l'IA et vÃ©rifie le format
    texte_complet = generer_probleme()
    
    # VÃ©rifie le format et regÃ©nÃ¨re si nÃ©cessaire
    tentatives = 1
    while not verifier_format_reponse(texte_complet) and tentatives < 3:
        print("[SystÃ¨me] Reformulation du problÃ¨me...")
        texte_complet = generer_probleme()
        tentatives += 1
    
    # Affiche uniquement la partie visible (sans les impacts)
    afficher_probleme(texte_complet)
    
    try:
        choix = int(input("\nRÃ©agissez en choisissant une solution (1, 2 ou 3) : "))
        if choix not in [1, 2, 3]:
            print("Choix invalide. Veuillez entrer 1, 2 ou 3.")
            continue
            
        # Extrait les impacts cachÃ©s, maintenant exclusivement fournis par l'IA
        impacts = extraire_impact(texte_complet, choix)
        
        # Affiche les impacts pour debug (Ã  retirer en production)
        # print(f"DEBUG - Impacts: {impacts}")
        
        # Applique les impacts aux jauges
        ajuster_jauges(impacts)
        
        print(f"\nVous avez choisi la solution {choix}. Les consÃ©quences se manifesteront au prochain tour.")
        time.sleep(1.5)
        
        tour += 1  # IncrÃ©mente le numÃ©ro du tour
        print(f"\nðŸ”„ Tour nÂ°{tour}")
        
        # Affiche la situation avec les tendances
        mort = afficher_situation()
        
    except ValueError:
        print("EntrÃ©e invalide. Veuillez entrer un nombre entre 1 et 3.")

print("\nMerci d'avoir jouÃ©!")
